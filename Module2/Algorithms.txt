Push Operation
Push operation used to insert an element into the stack.

Algorithm:
STEP1: START
STEP2: IF TOP = MAX-1
                PRINT 'OVERFLOW'
                go to step5
STEP3: SET TOP = TOP+1
STEP4: SET STACK [TOP] = VALUE
STEP5: END

Pop Operation
The pop operation is used to delete the top most element from the stack.

Algorithm:
STEP1: START
STEP2: IF TOP = NULL
                PRINT 'UNDERFLOW'
                go to STEP5
STEP3: SET VAL= STACK[TOP]
STEP4: SET TOP = TOP-1
STEP5: END

Peek Operation
Peek operation is the operation which returns the top most value of the stack without deleting it from the stack.

Algorithm:
STEP1: START
STEP2: IF TOP = NULL
                PRINT 'STACK IS EMPTY'
                go to STEP4
STEP3: RETURN STACK[TOP]
STEP4: END

OPERATIONS ON A LINKED STACK

Push Operation
The push operation is used to insert an element into the stack

STEP1: START
STEP2: Allocate memory for the new
        node and name it as NEW_NODE
STEP3:  SET NEW_NODE -> DATA = VAL
STEP4: IF TOP = NULL
        SET NEW_NODE NEXT = NULL
        SET TOP = NEW_NODE
Step5: END    

APPLICATIONS OF STACKS

In this section we will discuss typical problems where stacks can be easily applied for a simple
and efficient solution. The topics that will be discussed in this section include the following:

∑ Reversing a list
∑ Parentheses checker
∑ Conversion of an infix expression into a postfix expression
∑ Evaluation of a postfix expression
∑ Conversion of an infix expression into a prefix expression
∑ Evaluation of a prefix expression
∑ Recursion
∑ Tower of Hanoi


Convert the following infix expressions into postfix expressions.

 1.(A–B) * (C+D)
[AB–] * [CD+]
AB–CD+*

2.(A + B) / (C + D) – (D * E)
[AB+] / [CD+] – [DE*]
[AB+CD+/] – [DE*]
AB+CD+/DE*–

Convert the following infix expressions into prefix expressions.
Solution

(a) (A + B) * C
(+AB)*C
*+ABC

(b) (A–B) * (C+D)
[–AB] * [+CD]
*–AB+CD

(c) (A + B) / ( C + D) – ( D * E)
[+AB] / [+CD] – [*DE]
[/+AB+CD] – [*DE]
–/+AB+CD*DE

(b) A – (B / C + (D % E * F) / G)* H
Solution
Infix Character
Scanned       Stack          Postfix Expression
              (
A             (               A
–             ( –             A
(             ( – (           A
B             ( – (           A B
/             ( – ( /         A B
C             ( – ( /         A B C
+             ( – ( +         A B C /
(             ( – ( + (       A B C /
D             ( – ( + (       A B C / D
%             ( – ( + ( %     A B C / D
E             ( – ( + ( %     A B C / D E
*             ( – ( + ( % *   A B C / D E
F             ( – ( + ( % *   A B C / D E F
)             ( – ( +         A B C / D E F * %
/             ( – ( + /       A B C / D E F * %
G             ( – ( + /       A B C / D E F * % G
)             ( –             A B C / D E F * % G / +
*             ( – *           A B C / D E F * % G / +
H             ( – *           A B C / D E F * % G / + H
)                             A B C / D E F * % G / + H * –

Queues

1. Simple Queue (Linear Queue)
 The standard FIFO (First-In-First-Out) structure. Elements are added at the Rear and removed from the Front.
 Operations & Algorithm
 Enqueue: Check if Rear == MAX-1 (Overflow). If not, increment Rear and add the element.
 Dequeue: Check if Front == -1 or Front > Rear (Underflow). If not, return the element at Front and increment Front.
 Complexity AnalysisTime: $O(1)$ for both Enqueue and Dequeue.
 Space: $O(n)$.
 Drawback: Memory Wastage. Once Front moves forward, the space behind it cannot be reused even if the queue is technically not full.

2. Circular Queue
A circular queue solves the memory wastage of linear queues by connecting the last position back to the first.
 It uses the Modulo Operator ($\%$) for wrapping around.
 Operations & Algorithm
 Enqueue: Check if (Rear + 1) % MAX == Front (Full). If not, update Rear = (Rear + 1) % MAX and insert.
 Dequeue: Check if Front == -1 (Empty). If not, extract element. If Front == Rear, reset both to -1 (last element removed);
  otherwise, update Front = (Front + 1) % MAX.
Complexity Analysis
  Time: O(1) for Enqueue and Dequeue.
  Space: O(n).
  Advantage: Efficient memory utilization by reusing vacated slots.
   
3. Priority Queue
 In this type, each element is associated with a priority. Elements with higher priority are dequeued before elements with lower priority, regardless of their insertion order.
 
Operations & AlgorithmEnqueue: Insert the element into the structure (often a Binary Heap).
 Dequeue: Remove the element with the highest priority (the root of the heap).
 Algorithm (Max-Heap): After removal, move the last element to the root and "Heapify" down to maintain the heap property.
Complexity Analysis
 Time:Linked List/Array: O(n) for insertion or deletion (to maintain order).
 Binary Heap (Most common): O(\log n) for both Enqueue and Dequeue.
 Space: O(n).

 Queue Type            Enqueue      Dequeue               Best Use Case
   Simple                O(1)        O(1)              Basic buffer tasks
   Circular              O(1)        O(1)          Memory-constrained systems
   Priority             O(logn)     O(logn)  "CPU Scheduling, Dijkstra's Algorithm"