Linked list is basically a way of storing any data with address. 
It means we can store datas in two ways --
  * Array
  * Linked list
In the array when we store data then it has no address. just datas stored in a row manner one after another.
In Linked list we have two parts when we storing a data.
  1. data
  2. address
Data + Address = Node 
Address of the first node is known as Pointer.
Previous Node link the next node with the address of the next node.  

Here is the difference between Array and linked list is given in an easy way.

ðŸ”¹ Array vs Linked List (Simple Explanation)

 1. Memory Structure
Array
Stored in continuous (contiguous) memory
All elements are next to each other
Linked List
Stored in non-continuous memory
Each node contains data + address (pointer) of next node

Aftrall Linked list is the linked representation of the list.

 2. Size
Array
Fixed size (in most languages like C)
Cannot grow or shrink easily
Linked List
Dynamic size
Can grow or shrink during runtime

 3. Accessing Elements
Array
Direct access using index
arr[5] â†’ O(1)
Linked List
Sequential access only
Must start from head â†’ O(n)

 4. Insertion & Deletion
Array
Costly
Elements need to be shifted
â†’ O(n)
Linked List
Efficient
Just change pointers
â†’ O(1) (if position is known)

 5. Memory Usage
Array
Less memory (only data stored)
Linked List
More memory (data + pointer for each node)

 6. Cache Friendliness
Array
Cache-friendly (continuous memory)
Faster traversal
Linked List
Not cache-friendly
Slower traversal

 7. Wastage of Memory
Array
Possible wastage if size > elements
Linked List
No wastage (memory allocated as needed)

ðŸ”¹ What is a Self-Referential Structure?
A self-referential structure is a structure that contains a pointer to another variable of the same structure type.

ðŸ‘‰ In short:
A structure that refers to itself.

This is mainly used to create linked data structures like:
Linked Lists
Trees
Graphs

ðŸ”¹ Why do we need it?
Because structures cannot contain themselves directly, but they can contain pointers to their own type.
This allows us to connect multiple nodes dynamically.

ðŸ”¹ Example in C (Linked List Node)
struct Node {
    int data;
    struct Node *next;
};

Explanation:
data â†’ stores the value
next â†’ stores the address of another Node
struct Node *next;
ðŸ‘‰ This line makes it self-referential

[data | next] â†’ [data | next] â†’ [data | NULL]
Each node points to the next node of the same structure type.

ðŸ§  Step-by-Step: How to Create a Singly Linked List in C

1.Create the Node Structure
We need a structure that can point to another structure of the same type.

struct Node {
    int data;
    struct Node *next;
};

2.Declare Head Pointer
The head pointer stores the address of the first node.

struct Node *head = NULL;

3.Create a New Node (Memory Allocation)
We dynamically allocate memory for a node using malloc().

struct Node *newNode;
newNode = (struct Node *)malloc(sizeof(struct Node));

4.Assign Data to the Node

newNode->data = 10;
newNode->next = NULL;

5.Make This Node the First Node
Since the list is empty:

head = newNode;

Now the list looks like:

head â†’ [10 | NULL]

6.Create More Nodes (Repeat Process)
Create another node:

struct Node *second;
second = (struct Node *)malloc(sizeof(struct Node));

second->data = 20;
second->next = NULL;

7.Link Nodes Together
Connect the first node to the second:

head->next = second;

Now:

head â†’ [10 | next] â†’ [20 | NULL]

8.Traversing (Printing) the Linked List
We use a temporary pointer to move through the list.

struct Node *temp = head;

while (temp != NULL) {
    printf("%d -> ", temp->data);
    temp = temp->next;
}
printf("NULL");

Visit Porgramms.c for full code.

ðŸ”Traversing a Singly Linked List (Step by Step)

ðŸ”¹ What is Traversing?
Traversing means visiting each node of the linked list one by one, usually:
to display data
to search
to count nodes.

ðŸ”¹ What does â€œinsert at endâ€ mean?

Create a new node
Traverse the list till the last node
Make the last node point to the new node
New nodeâ€™s next should be NULL

Before:

10 â†’ 20 â†’ 30 â†’ NULL

After inserting 40 at end:

10 â†’ 20 â†’ 30 â†’ 40 â†’ NULL

STEP-BY-STEP EXPLANATION

ðŸ”¹ Step 1: Create the node structure
We need a self-referential structure.

struct Node {
    int data;
    struct Node *next;
};

ðŸ”¹ Step 2: Declare head pointer
head stores the address of the first node.

struct Node *head = NULL;

If head == NULL, the list is empty.

ðŸ”¹ Step 3: Create a new node
Allocate memory dynamically.

struct Node *newNode;
newNode = (struct Node *)malloc(sizeof(struct Node));

ðŸ”¹ Step 4: Assign data to the new node

newNode->data = value;
newNode->next = NULL;
ðŸ‘‰ next = NULL because it will be the last node.

ðŸ”¹ Step 5: Check if list is empty
Case 1ï¸âƒ£: Empty list
If head == NULL, then:
head = newNode;

Thatâ€™s it â€” new node becomes the first and last node.
Case 2ï¸âƒ£: List is NOT empty
You must traverse till the last node.

struct Node *temp = head;
while (temp->next != NULL) {
    temp = temp->next;
}


Now temp is pointing to the last node.

ðŸ”¹ Step 6: Link last node to new node

temp->next = newNode;

âœ” Insertion completed

ðŸ”¹ Step 7: Display the linked list (Traversal)

temp = head;
while (temp != NULL) {
    printf("%d -> ", temp->data);
    temp = temp->next;
}
printf("NULL");